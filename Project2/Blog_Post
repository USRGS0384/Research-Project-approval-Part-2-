Maze Project:


Development Process, Challenges, and Learnings.

Introduction
The Maze Project has been an exciting one, and a challenging journey for me. The past few weeks, i have worked to create a 2D maze game that is not only fun to play but also to prove my skills in software engineering. This blog post aims to reflect on the development process, and the valuable learnings gained along the way.


The Development Process

Project Planning and Proposal
The first step was to plan the project. I figured out  various ideas on  settling on the Maze Project. Outlined goals, defined the scope, and created a detailed project proposal.

Setting Up the Repository
I set up a GitHub repository to manage the  codebase. This included initializing the repository with a README.md file and setting up a branching strategy.

Design Phase
The design phase involved creating wireframes and mockups for the game’s user interface. Tools like Figma to visualize the layout and flow of the game is used. This step was crucial in ensuring a clear vision of what i  wanted to build.

Development Phase
Frontend Development: HTML, CSS, and JavaScript is used to build the user interface. Creating responsive and interactive game screens was a key focus.
Backend Development: For the maze generation algorithm, Python is used  due to its simplicity and powerful libraries. Flask was used to set up a lightweight web server.
Database: I integrated SQLite to manage game data, such as player scores and level progression.

Testing
Testing was a continuous process throughout development. I had to perform unit tests on the algorithms and conducted user testing to gather feedback on the gameplay experience. This helped to identify and fix bugs early.

Deployment
Finally, I deployed the project on a web server. Ensuring that the game was accessible and performed well on different devices was a priority.

Challenges

1 Algorithm Complexity- Developing an efficient maze generation algorithm was a significant challenge. I explored various algorithms, including Depth-First Search and Prim’s Algorithm, and ultimately decided on a modified version of Kruskal’s Algorithm for its balance between complexity and performance.

2 Collaborative Development- Not able to find a team required for effective communication and coordination was not easy. I encountered challenges in merging code changes and managing different versions of the project. Using Git and regularly syncing our work helped mitigate these issues.

3 UI/UX Design- Creating an intuitive and engaging user interface was harder than expected. I went through several iterations of the design based on user feedback to improve the overall experience.

4 Performance Optimization- Ensuring that the game ran smoothly on various devices was challenging. There had to be an optimization on the code and reduce resource usage, particularly for the maze generation and rendering processes.

Learnings
Importance of Planning- Thorough planning and clear documentation proved to be invaluable. It was organized and ensured that everyone was on the same page regarding project goals and deadlines.

Effective Communication- Updates were crucial in addressing issues promptly and keeping the project on track. Tools like Trello and Slack facilitated smooth communication and task management.

Adaptability- Being flexible and open to changes was essential. An approach several times based on new learnings and feedback, which ultimately led to a better final product.

Technical Skills- This project provided hands-on experience in various technologies, from frontend development with JavaScript to backend development with Python and Flask. We also improved our understanding of algorithms and data structures through the maze generation challenge.

Conclusion
The Maze Project has been a rewarding experience that not only tested our technical abilities but also our teamwork and problem-solving skills. We are proud of what we have achieved and excited to showcase this project in our portfolios. The challenges we faced and the lessons we learned will undoubtedly benefit us in our future endeavors as software engineers.
